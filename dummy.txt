


:value="name"
@input="name = $event.target.value"



:onValidate="(isValid) => checkValue(isValid)"


<f7-button fill large type="submit" @click="calculateDiameter">Berechnen</f7-button>



 else {
    const endresult = calculateDiameter();
  }





            @click="calculateDiameter"


          :onValidate="(isValid) => checkValue(isValid)"





          function checkValue(isValid) {
  let returnValue = 0;

  console.log(breite.value);
  console.log(dicke.value);

  const valueBreite = parseFloat(breite.value);
  const valueDicke = parseFloat(dicke.value);

  returnValue = valueDicke < valueBreite ? true : false;

  if (valueDicke < valueBreite) {
    let valueDicke;
    let valueBreite;
    console.log("(TRUE) Dicke(" + valueDicke + ") Breite("+ valueBreite +") RETURN: " + returnValue);
    return true;
  } else {
    console.log("(FALSE) Dicke(" + valueDicke + ") Breite("+ valueBreite +") RETURN: " + returnValue);
    return false;
  }
  //return returnValue;
}






const calculateDiameter = () => {
  const valueDicke = parseFloat(dicke.value);
  const valueBreite = parseFloat(breite.value);

  if (!compareValues(valueDicke, valueBreite)) {
    f7.dialog.alert(
      "Der Wert DICKE muss kleiner als der Wert BREITE sein.",
      () => {
        f7.loginScreen.close();
      }
    );
  } else {
    // Berechne Seitenverhältnis
    let calculatedAspectRatio = round(
      parseFloat(valueBreite) / parseFloat(valueDicke),
      100
    ); // auf 2 Stellen nach dem Komma gerundet
    let calculatedAspectRatioTrailingZeros = calculatedAspectRatio.toFixed(2);

    //console.log(typeof calculatedAspectRatioTrailingZeros);
    aspectRatio.value = calculatedAspectRatioTrailingZeros; // string!

    // Berechne Korrekturfaktor
    if (calculatedAspectRatio >= 1 && calculatedAspectRatio <= 5.0) {
      kFactorValue.value = kFactor[calculatedAspectRatioTrailingZeros];
    }

    // Berechne Korrekturfaktor für Seitenverhältnis grösser 5 und kleiner 17
    if (calculatedAspectRatio > 5 && calculatedAspectRatio <= 17.0) {
      kFactorValue.value = 0.958;
    }

    // Korrekturfaktor für die Berechnung
    let korrekturfaktor = kFactor[calculatedAspectRatioTrailingZeros];

    // Berechne Querschnittsfläche
    let calculatedCrossSectionArea = valueDicke * valueBreite * korrekturfaktor;
    crossSectionArea.value = calculatedCrossSectionArea.toFixed(4);

    // Berechne Rund-Duchmesser / Endergebnis
    r = Math.sqrt(calculatedCrossSectionArea / pi);
    d = r + r;
    result.value = d.toFixed(4);
  }
};